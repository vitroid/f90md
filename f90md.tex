\documentclass[a4,10pt]{article}
\usepackage{ascmac}
\usepackage[a4paper, portrait, margin=2cm]{geometry}
\parskip7pt
\parindent0pt
\usepackage{setspace}
%\doublespacing
\onehalfspacing

%% Utilities for TextWrangler
%% ([A-Za-z_0-9.\\\[\]]{2,})
%% {\\tt \1}
\title{f90md -- Molecular Dynamics in fortran90}
\begin{document}
\maketitle
%------------------------------------------------------------
\section{000はじめに}
%------------------------------------------------------------
MDを自分で書いてみる人のために、サンプルを書いてみました。

最速なプログラムを書くのにはあまり役に立ちません。複雑な分子を扱うことも今のところできません。
しかし、プログラムの書きはじめ方、コンパイルの仕方、プログラムの分割の方法、
機能を追加する方法などの参考にはなるかと思います。
\input git.tex

%------------------------------------------------------------
\section{010TwoBody}
%------------------------------------------------------------

分子動力学法の最も単純な例として、質量1の2つの質点がバネ定数1のバネでつながれた系の
運動(座標の時間変化)を、運動方程式を数値的に解くことで求めます。

物体の運動は、ニュートンの運動方程式
\begin{equation}
  {\bf F} = m {\bf a}
\end{equation}
に従います。ここで、Fはバネが物体に及ぼす力、mは質量、aは加速度です。
バネの力は、2つの物体の相対座標で決まります。また、加速度は座標の時間での2回微分ですから、この式を物体のかたほうについてもっと具体的に書くと、
\begin{equation}\label{eq:f_sp}
{\bf F}_1 = -k ({\bf r}_1- {\bf r}_2) = m_1 {\bf a}_1
\end{equation}
と書けます。力$\bf F$と位置$\bf r$と加速度$\bf a$はベクトルです。$k$はバネ定数です．作用反作用の法則により，もう一方の末端には逆向きの力が加わります．

ところで、加速度は速度を時間で微分したもの
\begin{equation}
a_x = \partial v_x / \partial t
\end{equation}
また速度は座標を時間で微分したものです。
\begin{equation}
v_x = \partial r_x / \partial t
\end{equation}
$_x$は速度や加速度ベクトルの$x$成分を表します．$y$，$z$成分も同様です．

これを、差分で近似的に表すと、(添字$_x$は省略しました)
\begin{eqnarray}
a(t)&=&[ v(t+\Delta t) - v(t) ] / \Delta t\\
v(t)&=&[ r(t+\Delta t) - r(t) ] / \Delta t
\end{eqnarray}
移項して書きなおすと、
\begin{eqnarray}
v(t+\Delta t) = v(t) + a(t) \Delta t\\
r(t+\Delta t) = r(t) + v(t) \Delta t
\end{eqnarray}
と書けます。つまり、現在の座標から力を計算し、力から運動方程式によって現在の加速度を計算し、現在の速度と加速度から少し未来の速度を、そして現在の座標と速度から少し未来の座標を計算できることがわかります。

この計算を繰り返し行うことで、物体の未来の位置と速度を計算できます。これが分子動力学法の中核です。プログラム{\tt main.f90}を上の式と見比べて、どこでどの計算をやっているかを想像してみて下さい。

このプログラムを実行するには、コンピュータが理解できる形に「翻訳」する必要があります。この作業をコンパイルと呼びます。{\tt main.f90}をコンパイルして、実行ファイル{\tt main}を作るには、ターミナルで
\begin{screen}\begin{verbatim}
gfortran main.f90 -o main
\end{verbatim}\end{screen}
と入力します。

エラーなくコンパイルできたら、
\begin{screen}\begin{verbatim}
./main
\end{verbatim}\end{screen}
と入力して下さい。{\tt "./"}は、``現在のディレクトリにある、''という意味を表しています。画面には何か数字がたくさん表示され、いかにもたくさん計算している雰囲気になります。

ちゃんとプログラムが動いていて、物理法則にのっとった運動をしているかどうかを確認するには、エネルギー保存則をチェックするのが簡単です。この系の場合、ポテンシャルエネルギーはバネのエネルギー
\begin{equation}\label{eq:e_sp}
E_p = k \left| r_1 - r_2 \right|^2 / 2
\end{equation}
運動エネルギーは2つの物体それぞれ
\begin{equation}
E_k = m \left| v \right|^2 / 2
\end{equation}
です。プログラムでは、これらの値を画面に出力するようになっています。

数値計算ですから、全エネルギーが厳密に一定になるわけではありませんが、運動エネルギーやポテンシャルエネルギーの時間変動に比べると、それらの和はほとんど変動しないことを、{\tt gnuplot}などでプロットして確認して下さい。

\begin{itembox}[l]{練習問題1}
バネのエネルギー(\ref{eq:e_sp})を末端間距離$r$で微分すると，バネの両端に加わる力(\ref{eq:f_sp})が求められます．
\begin{eqnarray}
E_p(r)&=&kr^2/2\\
{\bf F}&=&-\frac{\partial E_p(r)}{\partial {\bf r}}\\
&=&-\frac{\partial E_p(r)}{\partial r}\frac{\partial r}{\partial {\bf r}}\\
&=&-k{\bf r}
\end{eqnarray}
クーロンポテンシャル関数$V(r) = k / r$を微分して、クーロンポテンシャルで相互作用する2つの物体に加わる力のベクトルを数式として求めて下さい。
\end{itembox}

\begin{itembox}[l]{練習問題2}
実際に2つの物体(2次元でも3次元でも構わない。座標はてきとうに決める)の間に働くポテンシャルエネルギーと、物体の座標をわずかにずらした時のエネルギー変化から、上の式が正しいかどうかを検証するプログラムを書きましょう。
\end{itembox}

%------------------------------------------------------------
\section{020TwoBodyLJ}
%------------------------------------------------------------

2つの質点をつなぐバネの代わりに、Lennard-Jones相互作用を導入します。
対エネルギーの計算と力の計算が多少複雑になります。

\begin{itembox}[l]{練習問題3}
Lennard-Jones相互作用でも、クーロン力と同様の手順で確認して下さい。
\begin{equation}
    E_p(r) = A/(r^p) - B/(r^q)
\end{equation}
\end{itembox}


%------------------------------------------------------------
\section{030NBody}
%------------------------------------------------------------

質点の個数を8個に増やします。
座標を個々に指定するのは面倒なので、格子点の座標を生成するループを追加しました。
今のところ、分子数は8個に固定ですが、あとで自由に増やせるようにします。


%------------------------------------------------------------
\section{040Readability}
%------------------------------------------------------------

読みやすさを改善するために、中身がわかりやすい変数名にしましょう。
座標には{\tt position}, 速度は{\tt veolcity}といった名前をつけます。
変数名の長さは実行速度には関係ありませんが、長くすることで間違いを減らすことができます。
例えば、{\tt vx}と書いたつもりで{\tt yx}や{\tt vy}と書いてあっても、書きまちがった名前の変数が定義されて
いれば、コンパイラはエラーを出さずに見逃してしまいます。

もう一点は、座標をx,y,zと明示するのではなく、3変数の配列で表します。
例えば、座標は
\begin{screen}\begin{verbatim}
real(kind=8) :: x(8),y(8),z(8)
\end{verbatim}\end{screen}
と書く代わりに、
\begin{screen}\begin{verbatim}
real(kind=8) :: position(3,8)
\end{verbatim}\end{screen}
と書きます。

{\tt fortran90}では、配列の変数全体に一斉に同じ計算をさせるための、特別な書き方があります。
例えば、座標を全部0にしたい場合、従来通りの記法で書くなら、
\begin{screen}\begin{verbatim}
 do i=1,8
   x(i) = 0d0
   y(i) = 0d0
   z(i) = 0d0
 end do
\end{verbatim}\end{screen}
と書くところを、
\begin{screen}\begin{verbatim}
 position(:,:) = 0d0
\end{verbatim}\end{screen}
と簡単に書けます。

この書き方は、単にコード量が少なくなるだけでなく、
(並列やベクトル化などの技術を駆使して)プログラムを高速に実行させたい場合に、
コンパイラがより理解しやすく、最適化しやすい(はず)ので、積極的に使いましょう。

\begin{shadebox}
    プログラムを読みやすく書く習慣をつけましょう。他人に見せないからスタイルは気にしない、と言う人もいますが、スタイルを気にせず書いてしまったから他人には見せたくても見せられないのかもしれません。きれいなプログラムを書くのは、他人のためではなく、未来の自分のためです。自分が書いたプログラムを一番頻繁に読むのは、自分自身です。どんなに時間をかけて書いたプログラムでも、しばらく時間がたつと全体像があやふやになります。分かりやすいプログラムを書いておけば、次にプログラムを改良する必要が生じたときに、間違いをおかさず、すみやかに作業を終えることができます。汚なく書いてもかまわないのは、使い捨ての短いプログラムだけです。
\end{shadebox} 

\begin{shadebox}
	プログラムを大幅に書換える前にコピーを作っておき，変更前とあとで、出力される結果が全く変化しないことをいつも確認しましょう。
\end{shadebox}



%------------------------------------------------------------
\section{050FileIO}
%------------------------------------------------------------

プログラムの中で分子の座標を生成するだけだと、任意の初期配置から計算をはじめることが
できないので、座標はファイルから読みこめるようにしましょう。

ファイルから読みこむ場合、読みこみはじめるまで、分子の個数がわかりませんから、
配列もどれだけの大きさにしておけばいいかわかりません。
1000分子分の配列をとってあっても、実際に読みこんだ分子数が10個ならメモリの無駄遣い
(メモリを無駄に使うと、処理速度は落ちます)だし、逆に10個分しか配列を作っていないのに
1000分子を読みこもうとすると、エラーになります。

そこで、配列の大きさをあとから指定できるように、座標の配列を可変長としておきます。
\begin{screen}\begin{verbatim}
real(kind=8), allocatable :: position(:,:)
\end{verbatim}\end{screen}

読みこむ座標ファイルには、最初の行に分子数が書いてあり、
そのあとに座標が分子数分列挙されているものとします。
ファイルの最初の行を読みこんだら、その値に応じて配列の大きさを決定します。
\begin{screen}\begin{verbatim}
allocate(position(3,num_molecule))
\end{verbatim}\end{screen}

読みこむ分子座標のデータがまだないので、それを生成するプログラム{\tt scl.f90}を追加しました。
このプログラムは、格子定数$4 {\rm \AA}$で分子数27の単純立方格子の座標を作ります。
そして、画面に出力します。この出力内容を{\tt main.f90}に読ませます。
{\tt scl}と{\tt main}を組みあわせる方法は、{\tt run.sh}に書いてあります。
{\tt run.sh}を走らせると、27分子の分子動力学計算が実行されます。


%------------------------------------------------------------
\section{060Unit}
%------------------------------------------------------------

ちょっと立ち止まって、ファイルや画面に表示される値がどういう単位系なのかを考えてみましょう。

単位系は各自で自由に選んで構いませんが、すべての変数で矛盾がないようにする必要があります。このサンプルプログラムでは、以下の単位系を使っています。
\begin{center}
\begin{tabular}{cc}
\hline
 エネルギー&kJ/mol\\
 圧力&Pa\\
 長さ&Angstrom = $10^{-10}$ m\\
 時間&pico sec = $10^{-12}$ sec\\
 \hline
 \end{tabular}
\end{center}

%------------------------------------------------------------
\section{070TaggedFileIO}
%------------------------------------------------------------

読みこむデータファイルには、分子数と座標を書いておくことにしましたが、
ほかにもいろいろ設定したい情報はあります。
また、読みこむだけでなく、計算結果を使って、続きの計算をしたい場合もあるでしょう。

今のプログラムでは、ループの回数もプログラム中で直に指定しているので、
ループ回数を変えようと思ったら、プログラムを書換えなければいけません。

プログラムは日々書換え、拡張して使うものですが、計算して得られたデータは、
書換えることはありません。もし、データの中に、それが何を表す数値かが明記されて
いなければ、プログラムを拡張して書換えているうちに、データの意味がわからなくなってしまいます。
データの意味がわからなくなれば，それはただのゴミです．

ですから，データファイルを、単なる数値の羅列にしてはいけません。
プログラムがなくても数値の意味がわかるように、データファイルは書かれているべきです。

そこで、それぞれのデータに、名前(ラベル、タグ)をつけることにします。
例えば、分子数をデータファイルに書く時には、その数値の前に「分子数」と書いておくわけです。
こうすることで、データファイルをあとから見た時に、その意味が一目瞭然になります。
さすがに日本語のラベルはfortranでは扱いづらいので、
角括弧でくくったアルファベットでラベルをつけることにしました。

名前をつけるもうひとつのメリットは、データの並び順を気にしなくてよくなることです。

ラベルは自由に決めてかまいません。他人と共通にする必要もありません。データの可搬性を考えるとXMLなどの汎用フォーマットを使いたくなるかもしれませんが，いまはそこまで必要ないでしょう．データの意味さえわかっていれば、フォーマットを相互変換するプログラムは簡単に書けます．ただし、ラベルは人間が理解するためのものである以上に、プログラムがデータの種類を見分ける手段でもあります。プログラムを拡張していく過程で、データの書式を変更したくなることがあると思いますが，データの書式を変更する時には、必ずラベルも変更して下さい。そうしないと、プログラムはデータフォーマットの違いに気付かず、間違った解釈をしてしまいます。ということは、プログラムを改良するにつれ、必然的に同じようなデータを表すラベルが何種類も生じることになります。

逆に、当初の使い方とは違う用途に、おなじデータフォーマットを使う場合も生じます。例えば、アルゴン分子の座標を示すデータラベルとして、
\begin{screen}\begin{verbatim}
[ARGON POSITIONS]
\end{verbatim}\end{screen}
というようなラベルを作ったあとで、全く同じプログラムでキセノンのシミュレーションをしたくなった時に、データフォーマットは全く変更する必要がないのに、
\begin{screen}\begin{verbatim}
[XENON POSITIONS]
\end{verbatim}\end{screen}
というラベルを新設しなければならなくなるかもしれません。そして、ラベルの種類が増えるほど、プログラム側で行う処理が煩雑になります。あまりdescriptiveなラベルを使うのも考えものです。

ラベルは使いすてるつもりで、
\begin{screen}\begin{verbatim}
[POS3]
\end{verbatim}\end{screen}
ぐらいの、あまり記述的でないラベルを使っておくほうが無難でしょう。

Lennard-Jones相互作用のパラメータやループの回数、数値積分の$\Delta t$など、
設定できるものは何でもタグを付けてファイルから読みこめるようにしました。
Lennard-Jonesパラメータや分子質量は、もはやArgonの値を示しているとは限らないので、
変数名から{\tt argon}を除去しました。

{\tt scl.f90}も、タグ付きのフォーマットでデータを生成するように変更しました。
座標を生成し、その他のパラメータとあわせて、{\tt main}に読みこませて実行する方法は、
{\tt run.sh}に書いてあります。


%------------------------------------------------------------
\section{080Cell}
%------------------------------------------------------------

無限空間に分子がうかんだクラスタ系のプログラムをこれまで書いてきましたが、
容器のなかにとじこめられた状態を実現するために、周期境界条件を満足する直方体の
シミュレーションボックスを導入します。

とはいっても、変更点はほんのわずかです。
このわずかな変更で、なぜ周期境界条件を
実現できるのか、じっくり考えてみて下さい。


%------------------------------------------------------------
\section{090Pressure}
%------------------------------------------------------------

体積が確定すると、圧力が計算できます。分子動力学法では、圧力はVirialという量から
算出します。


%------------------------------------------------------------
\section{100Modular}
%------------------------------------------------------------

だんだんプログラムが長くなってきました。(文章を書くのも面倒になってきました)
コメントをたくさん書き込み、できるだけ詳しい説明を入れながらプログラムを書いていても、プログラム全体がパソコンの画面におさまらない長さになってくると、全体像を理解するのが難しくなってきます。ざっと目を遠すには、1つの処理は40〜60行程度(プリンタ用紙1枚程度)におさめるのがよさそうです。

そこで、プログラムを小さい部品に分割します。個々の部品の機能を明確にしておけば、
部分をみて全体を把握しやすくなります。

...fortranの{\tt module}機能を使います。

\subsection{{\tt module}を使う場合の注意点}
\subsubsection{{\tt module}は構造体でもオブジェクトでもない。}
モジュールは単にサブルーチンを束ねたものです．それ以上でもそれ以下でもありません．モジュールには変数が含まれますが，構造体やクラスのようにコピーを作ることはできず，モジュール内変数は単なるグローバル変数と違いがありません．例えば「分子」というモジュールを1つ作って，いろんな種類の分子を派生させる，というような使い方は想定されていません．
\footnote{fortranよりも前に，c++やJavaなどのオブジェクト指向言語を学んだ人が見ると，いかにも中途半端です．なぜこんな中途半端なものが作られたのか，というと，FORTRAN77で悪評の高かった{\tt common}文を廃止するためだと思われます．モジュール内変数は，同じモジュールに含まれる関数からは自由に参照できます．

module指向という考え方はオブジェクト指向よりも前に提唱され，オブジェクト指向は90年代よりもあとに普及したので，fortran90がモジュールにしか対応していないのはしかたありません．その後，fortranもオブジェクトを使えるように拡張されたようですが，つぎはぎで拡張され延命されるさまを見ていると，もうそろそろfortranにこだわらなくてもいいんじゃないかと思います．(BASIC言語もそうですが)
\begin{quote}
If all you have is a hammer, everything looks like a nail.
\end{quote}
}
\begin{itemize}
%\item {\tt module}内変数はグローバル変数。ではない．private宣言がある．
\item モジュール間での名前の衝突，別名の定義
\item モジュールに分けると読みやすくなるが、安全にはならない。
\item {\tt intent}を使おう。
\item あまり依存関係が複雑になりすぎないようにする。
\item 関数名のつけかた
\item (分割コンパイルの方法。)
\end{itemize}



%------------------------------------------------------------
\section{110Symplectic}
%------------------------------------------------------------

プログラムをモジュールに分割して、全体の見通しがよくなったところで、
数値積分の方法を再考します。

あらかじめサブルーチンに分けてあるので、書換えは非常に簡単です。



%------------------------------------------------------------
\section{混合物への拡張}
%------------------------------------------------------------

混合物を扱うために、どんな拡張が必要になるか考えてみましょう。
とりあえず、分子はこれまでと同じく、単原子分子を想定します。

まず、2種類以上の分子種を扱うわけですから、分子の座標や速度の情報も、分子種ごとに保持する必要があります。

一つの方法としては、{\tt properties}モジュールに含まれる、座標や速度の配列を長くして、
全分子をおさめてしまうという手が考えられます。
しかし、これだと、どこまでがどの分子の情報かわかりにくいし、
おそらく分子種が増えてくるにつれて、非常に読みづらいプログラムになると思われます。

では、{\tt properties}モジュールを複製して、もうひとつ{\tt properties2}モジュールを作ったらどうでしょうか。
確かに、2種類の分子を、2種類のモジュールで管理すれば、先の場合のようなややこしさは回避できます。
しかし、3種類、4種類と分子種が増えてくるにつれて、モジュールを増やしていくと、ほぼ同じ内容の
モジュールがいくつもでき、メンテナンス上の問題がだんだん無視できなくなります。
\footnote{モジュールの配列みたいなものが作れればいいんですけど，先にも書いたようにモジュールはオブジェクトとは違うので，1つ作って複製する，というわけにいきません．}

では、一つの{\tt properties}モジュールの中で、座標や配列の次元を1つ増やして、分子種を使いわけるという方法ではどうでしょう。これは一見うまくいきそうですが、例えば100万分子の成分Aの中に、1分子の成分Bが溶けているような状況を考えた場合、成分Bの配列はほとんど無駄になります。これも、スマートな解決法とは言えません。

もう一つの方法として、{\tt properties}内のモジュール変数を、全部構造体にまとめてしまい、その構造体を、分子種ごとにいくつも動的に作成する、という方法があります。この方法なら、構造体ごとにメモリ使用量を調節できますし、分子種がいくつ増えてもその都度モジュールを増やす必要はありません。以下では、この方針で、プログラムを書換えていくことにします。

%------------------------------------------------------------
\section{130Mixture}
%------------------------------------------------------------

さて、{\tt properties}モジュールには、分子の座標や速度、個数、質量、Lennard-Jones相互作用パラメータなどの情報が含まれています。このうち、Lennard-Jones相互作用パラメータは本当に分子の属性と呼べるでしょうか。というのも、2種類以上の分子が混在する場合、相互作用パラメータは、分子種の個数分だけでなく、異種分子の組みあわせすべてについて、個別に適切に設定する必要があります。通常は、異種Lennard-Jones分子間の相互作用はLorentz-Berthelot則を適用し、
\begin{equation}
 \sigma_{12} = (\sigma_1+\sigma_2)/2,\\
 \epsilon_{12} = \sqrt{\epsilon_1 + \epsilon_2}
 \end{equation}
で計算しますが、それをプログラムの中にハードコードしてしまうのはあまりスマートとは言えません。分子間相互作用のパラメータは、分子の属性とするよりも、力計算モジュールの属性とするほうが自然でしょう。そこで、まず最初のステップとして、Lennard-Jones相互作用パラメータを、{\tt force\_module}に移動し、モジュールの名前も{\tt interaction\_module}に変更します。(次のセクションでさらに大改造します)

%------------------------------------------------------------
\section{135Mixture2}
%------------------------------------------------------------

構造体を導入するには、さらに大手術が必要になります。まず、{\tt properties\_module}は、いろんな種類の分子をまとめる場所として使い、個々の分子団は別のモジュールにわけます。ここでは、単原子分子のつもりで、{\tt monatom\_module}を作りました。単原子分子の構造体はこのモジュールで定義し、この構造体を操作するサブルーチンも全部このモジュールの中におしこみます。

{\tt monatom\_module}の中身は、旧{\tt properties\_module}とほとんど同じですが、後者ではモジュール変数に対して処理を行っていたのを、前者では構造体に対して処理を行うように書換えました。これにより、同じサブルーチンを、異なる分子群に対して使えるようになります。

{\tt properties\_module}のほうは、混合物の成分数だけ{\tt monatom\_type}構造体を持ち、個々のサブルーチンが{\tt main}から呼びだされると、各成分に処理をふりわけるだけの役割になります。

\begin{shadebox}
    このチュートリアルでは、モジュール名には必ず{\tt \_module}を、構造体名には必ず{\tt \_type}を    付けることにしています。このように、名前がデータの型を表すようにするのは、少し冗長な感じもしますが、プログラムが大きくなってきて、全体が見渡せなくなってきたり、多人数で開発を行うようになった時に、読み間違い/書き間違いが生じないようにする工夫です。もっと学びたい人は「変数の命名規則」で検索してみて下さい。
\end{shadebox}
多成分系では、データの読み込み方法も工夫が必要になります。これまでなんとなくArgon分子のパラメータとしてきた、座標や速度、質量、相互作用パラメータのうち、相互作用パラメータだけは、扱いが大きくかわります。

というのも、相互作用は、その名の通り、分子そのものの属性というよりは、分子(群)の間で定義されるものだからです。2成分系であれば、座標、質量は2種類の分子の情報を読みこむ必要がありますが、相互作用は、3種類(同種同士が2通り、異種分子間相互作用が1通り)を定義する必要があります。

まず、分子の情報である、座標と分子量を読み込む前に、[{\tt COMPONENT}]というタグを付けて、新しい成分についてのデータがこのあとに来るよ、ということを明示するようにしました。
[{\tt COMPONENT}]が入力データに出現するたびに、成分が1つずつ増えます。

そして、相互作用は{\tt [COMPONENT]}とは全く別に、{\tt [INTRPAIR]}タグで指定することにします。これまでの{\tt [LJPARAM]}は使わなくなり、将来の拡張性も見据えて、相互作用の種類を指定できるようにします。

例えば、成分1と成分1がLennard-Jones相互作用する場合には、
\begin{screen}\begin{verbatim}
 [INTRPAIR]
 1 1 LJ
 <LJのepsilon> <LJのsigma>
\end{verbatim}\end{screen}
という形で指定します。将来、Lennard-Jones以外の相互作用を扱う場合には、"LJ"の部分が別のラベルに代わり、3行目のパラメータもそれに応じて個数が変わってきます。

"LJ"の代わりに"LB"と書くと、Lorentz-Berthelot則でepsilonとsigmaを計算します。
この場合は3行目のパラメータは不要です。
\begin{screen}\begin{verbatim}
 [INTRPAIR]
 1 2 LB
\end{verbatim}\end{screen}

ところで、
\begin{screen}\begin{verbatim}
 1 1 LJ <LJのepsilon> <LJのsigma>
\end{verbatim}\end{screen}
のように全部1行に書いてしまえばいいじゃないかと思うかもしれません。しかし、上のように分けておくことで、まず相互作用の種類を読みこみ、それに応じて読みこむパラメータ数を変化させることができます。fortran90でファイルからデータを読みこむ場合はいろいろ制約が多いので、データ形式もそれに配慮して定義しておくと、将来何度もデータフォーマットを変更するのを回避できます。

さて、{\tt properties}から{\tt monatom}を分離したのと同じように、{\tt interaction\_module}から{\tt lj\_module}を分離し、{\tt interaction\_module}は相互作用の処理のふりわけだけをするように書換えました。実際の相互作用の計算は{\tt lj\_module}が担当します。{\tt lj\_module}の中では、もともと{\tt force\_calculate}と呼ばれていたルーチンは、{\tt lj\_calculate\_homo}と{\tt lj\_calculate\_hetero}の2つに分かれていて、それぞれ同種分子と異種分子の間の相互作用計算を担当します。これらの振り分けは{\tt interaction\_calculate}が行います。現在のコードでは、成分数は最大100成分までとなっていますが、多少多すぎるかもしれません。{\tt lj\_pair}については、いずれ改良する予定です。

\begin{shadebox}
    {\tt lj\_module}の中のサブルーチン/関数は、必ず第一引数が{\tt lj\_type}となっています。{\tt monatom\_module}の場合も同じです。同じ構造体を扱うサブルーチンばかりをひとまとめにしたものを、プログラミングの世界ではオブジェクトと呼びます。また、そのようにまとめることで、プログラムの見通しを良くしようという考え方を、オブジェクト指向と呼びます。オブジェクト指向にすると実行速度が遅くなるといった批判もありますが、多くはJavaなどのインタプリタ言語で、動的なメモリの確保と解放を積極的に行い、なおかつ多態を多用する場合の話のようです。いまここで説明している限りでは、コンパイラ言語で、動的メモリの確保はプログラムの起動時にしかおこなわず、多態もまだ使っていないので、悪影響は心配しなくて良いと思います。このチュートリアルでは、プログラムの変更により、明らかに遅くなった場合には、何が原因かを追究し、プログラムの読みやすさを損ねずに改善する方法も紹介します。
\end{shadebox}

{\tt properties\_module}と{\tt interaction\_module}をうまく拡張したので、{\tt main}の中身はほとんど変更の
必要がありませんでした。
力の初期化は、これまでは力計算ルーチン{\tt force\_calculate}のはじめで行っていました。しかし、
多成分系では、いろんな成分の組み合わせの間で力を計算し、それらを累積する必要があります。
そこで、{\tt force\_calculate}({\tt interaction\_calculate}に改称)を呼ぶ前後で、{\tt properties\_preforce()}
を呼びだして初期化させるようにしました。

さいごに、動作試験をするための初期構造を生成する、{\tt gen\_2compo.f90}を準備しました。
{\tt scl.f90}では、単純格子を生成しました。{\tt gen\_2compo.f90}は、単純格子を2分して、2つの成分に
ふりわけます。実際には、2つの成分の相互作用は全く同じにすれば、計算結果も全く同一になるはずです。
{\tt scl.f90}のほうは、入力データ形式が変更されたのにあわせて、多少内容を変更し、{\tt gen\_scl.f90}という
名前に変更しました。

また、これらを組みあわせ、格子を生成してMDを実行するスクリプト{\tt run\_scl.sh}と{\tt run\_2compo.sh}も
準備しました。1成分でも、2成分に分割しても、全く同じ結果が得られることを確認して下さい。
また、スクリプトが生成する、{\tt main}用の入力データ{\tt *.input}の中身を見れば、
1成分の場合と2成分の場合のデータの違いを見比べることができます。

\begin{shadebox}
    シェルスクリプトなどが生成する中間ファイルは、ファイル名が"@"ではじまるように統一します。
    これは、大昔の汎用計算機時代の名残り(短期ファイルの目印)なんですが、もはや誰も覚えていないし、
    検索しても出てこないようです。田中先生なら知っているはず。
\end{shadebox}


\begin{itembox}[l]{練習問題4}
100ステップ後にファイルに出力した結果を、再度読みこんでさらに100ステップ継続計算した場合と、
    200ステップ連続で計算した場合の結果が一致するかどうかを確認するスクリプトを作りましょう。	混合物と単成分で同じ結果になるかどうかを確認して下さい。
    \end{itembox}



%------------------------------------------------------------
\section{今後の予定}

各セクションで、確認しておくべき点、テスト手法を示すか、課題とする。!!!!

\begin{itemize}
\item 実行速度の評価方法と改善方法
\item 熱浴(温度調節) Berendsen and Nose-Hoover
\item 正しい結果が得られているかどうかを検証する方法、デバッグ手法、テスト手法、分析(動径分布関数など)
\item DONE 混合物
\end{itemize}
\section{今後の未定}
\begin{itemize}
\item 剛体分子
\item カットオフ、相互作用計算の高速化
\item クーロン力、長距離相互作用の操作
\item 能勢の熱浴
\item 圧力調節
\item さまざまな境界条件
\item 並列化
\end{itemize}
\end{document}

